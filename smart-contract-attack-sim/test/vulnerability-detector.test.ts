import * as path from 'path';
import { parseFile, extractContractInfo } from '../src/utils/parser';
import { detectVulnerabilities } from '../src/vulnerability-detector';
import { Vulnerability } from '../src/types';

const FIXTURES_DIR = path.join(__dirname, 'fixtures');

function analyzeFixture(filename: string): Vulnerability[] {
  const filePath = path.join(FIXTURES_DIR, filename);
  const { ast } = parseFile(filePath);
  const parsed = extractContractInfo(ast);
  return detectVulnerabilities(parsed);
}

describe('Vulnerability Detector', () => {
  describe('Reentrancy Detection', () => {
    it('should detect reentrancy in vulnerable-reentrancy.sol', () => {
      const vulns = analyzeFixture('vulnerable-reentrancy.sol');

      const reentrancyVulns = vulns.filter((v) => v.type === 'reentrancy');

      expect(reentrancyVulns.length).toBeGreaterThanOrEqual(1);
      expect(reentrancyVulns[0].severity).toBe('CRITICAL');
      expect(reentrancyVulns[0].location.functionName).toBe('withdraw');
    });

    it('should NOT detect reentrancy in clean-contract.sol (CEI pattern)', () => {
      const vulns = analyzeFixture('clean-contract.sol');

      const reentrancyVulns = vulns.filter((v) => v.type === 'reentrancy');

      expect(reentrancyVulns.length).toBe(0);
    });
  });

  describe('Access Control Detection', () => {
    it('should detect missing access control in vulnerable-access-control.sol', () => {
      const vulns = analyzeFixture('vulnerable-access-control.sol');

      const accessControlVulns = vulns.filter((v) => v.type === 'access-control');

      // Should detect pause, unpause, mint
      expect(accessControlVulns.length).toBeGreaterThanOrEqual(3);
      expect(accessControlVulns.every((v) => v.severity === 'HIGH')).toBe(true);

      const funcNames = accessControlVulns.map((v) => v.location.functionName);
      expect(funcNames).toContain('pause');
      expect(funcNames).toContain('unpause');
      expect(funcNames).toContain('mint');
    });

    it('should NOT flag functions with onlyOwner modifier', () => {
      const vulns = analyzeFixture('clean-contract.sol');

      const accessControlVulns = vulns.filter((v) => v.type === 'access-control');

      // adminWithdraw has onlyOwner, should not be flagged
      const adminWithdrawVuln = accessControlVulns.find(
        (v) => v.location.functionName === 'adminWithdraw'
      );
      expect(adminWithdrawVuln).toBeUndefined();
    });
  });

  describe('Integer Overflow Detection', () => {
    it('should detect overflow in pre-0.8.0 contracts', () => {
      const vulns = analyzeFixture('vulnerable-overflow.sol');

      const overflowVulns = vulns.filter(
        (v) => v.type === 'integer-overflow' || v.type === 'integer-underflow'
      );

      expect(overflowVulns.length).toBeGreaterThanOrEqual(1);
      expect(overflowVulns.some((v) => v.severity === 'HIGH')).toBe(true);
    });

    it('should NOT detect overflow in 0.8.0+ contracts (built-in checks)', () => {
      const vulns = analyzeFixture('clean-contract.sol');

      const overflowVulns = vulns.filter(
        (v) => v.type === 'integer-overflow' || v.type === 'integer-underflow'
      );

      expect(overflowVulns.length).toBe(0);
    });
  });

  describe('Clean Contract (No False Positives)', () => {
    it('should detect zero vulnerabilities in clean-contract.sol', () => {
      const vulns = analyzeFixture('clean-contract.sol');

      expect(vulns.length).toBe(0);
    });
  });

  describe('Multiple Vulnerabilities', () => {
    it('should detect multiple vulnerability types in multiple-vulns.sol', () => {
      const vulns = analyzeFixture('multiple-vulns.sol');

      // Should have at least reentrancy + access control issues
      const reentrancyVulns = vulns.filter((v) => v.type === 'reentrancy');
      const accessControlVulns = vulns.filter((v) => v.type === 'access-control');

      expect(reentrancyVulns.length).toBeGreaterThanOrEqual(1);
      expect(accessControlVulns.length).toBeGreaterThanOrEqual(2);
    });

    it('should correctly assign severity levels', () => {
      const vulns = analyzeFixture('multiple-vulns.sol');

      const criticalVulns = vulns.filter((v) => v.severity === 'CRITICAL');
      const highVulns = vulns.filter((v) => v.severity === 'HIGH');

      // Reentrancy should be CRITICAL
      expect(criticalVulns.some((v) => v.type === 'reentrancy')).toBe(true);

      // Access control should be HIGH
      expect(highVulns.some((v) => v.type === 'access-control')).toBe(true);
    });
  });

  describe('Vulnerability Properties', () => {
    it('should include all required properties in vulnerabilities', () => {
      const vulns = analyzeFixture('vulnerable-reentrancy.sol');

      expect(vulns.length).toBeGreaterThan(0);

      const vuln = vulns[0];
      expect(vuln).toHaveProperty('id');
      expect(vuln).toHaveProperty('type');
      expect(vuln).toHaveProperty('severity');
      expect(vuln).toHaveProperty('title');
      expect(vuln).toHaveProperty('description');
      expect(vuln).toHaveProperty('location');
      expect(vuln).toHaveProperty('attackVector');
      expect(vuln).toHaveProperty('recommendation');
      expect(vuln).toHaveProperty('exploitable');
    });

    it('should include location details', () => {
      const vulns = analyzeFixture('vulnerable-reentrancy.sol');

      const vuln = vulns[0];
      expect(vuln.location).toHaveProperty('line');
      expect(vuln.location).toHaveProperty('functionName');
      expect(vuln.location).toHaveProperty('contractName');
      expect(vuln.location.line).toBeGreaterThan(0);
    });
  });
});
