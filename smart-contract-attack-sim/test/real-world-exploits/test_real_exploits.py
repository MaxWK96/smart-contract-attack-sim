#!/usr/bin/env python3
"""
Real-World Exploit Validation Test Suite
Tests the analyzer against 5 known real-world exploits.
"""

import json
import urllib.request
import urllib.error
from datetime import datetime

API_URL = "http://localhost:3000/api/analyze"

# =============================================================================
# EXPLOIT 1: The DAO (Reentrancy) - June 2016, $60M stolen
# =============================================================================
DAO_CONTRACT = '''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * Simplified version of The DAO vulnerability
 * Original: splitDAO() function had reentrancy bug
 * This demonstrates the same pattern: external call before state update
 */
contract TheDAO {
    mapping(address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    // VULNERABLE: Same pattern as original DAO
    // External call happens BEFORE balance is set to 0
    function splitDAO(address recipient) external {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance");

        // BUG: External call before state update
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed");

        // TOO LATE - attacker already re-entered
        balances[msg.sender] = 0;
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}'''

# =============================================================================
# EXPLOIT 2: Parity Wallet (Unprotected Selfdestruct) - Nov 2017, $280M frozen
# =============================================================================
PARITY_CONTRACT = '''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * Simplified version of Parity Multisig Wallet vulnerability
 * Original: initWallet() could be called by anyone on library contract
 * Then kill() could be called to selfdestruct the library
 */
contract ParityWalletLibrary {
    address public owner;
    bool public initialized;

    // VULNERABLE: Anyone can call this to become owner
    function initWallet(address _owner) external {
        require(!initialized, "Already initialized");
        owner = _owner;
        initialized = true;
    }

    // VULNERABLE: No access control on selfdestruct!
    // Original Parity bug: kill() had no modifier
    function kill() external {
        selfdestruct(payable(msg.sender));
    }

    function deposit() external payable {}

    function execute(address to, uint256 value, bytes calldata data) external {
        require(msg.sender == owner, "Not owner");
        (bool success, ) = to.call{value: value}(data);
        require(success, "Execution failed");
    }
}'''

# =============================================================================
# EXPLOIT 3: Access Control Bug (Generic privilege escalation)
# =============================================================================
ACCESS_CONTROL_CONTRACT = '''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * Generic access control vulnerability
 * Critical admin functions without protection
 */
contract VulnerableToken {
    mapping(address => uint256) public balances;
    address public owner;
    uint256 public totalSupply;
    bool public paused;

    constructor() {
        owner = msg.sender;
        totalSupply = 1000000;
        balances[msg.sender] = totalSupply;
    }

    // VULNERABLE: No access control - anyone can mint tokens!
    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balances[to] += amount;
    }

    // VULNERABLE: No access control - anyone can pause!
    function pause() external {
        paused = true;
    }

    // VULNERABLE: No access control - anyone can set new owner!
    function setOwner(address newOwner) external {
        owner = newOwner;
    }

    // VULNERABLE: No access control - anyone can drain funds!
    function withdrawAll(address to) external {
        payable(to).transfer(address(this).balance);
    }

    function transfer(address to, uint256 amount) external {
        require(!paused, "Contract paused");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }

    receive() external payable {}
}'''

# =============================================================================
# EXPLOIT 4: King of Ether (Unchecked Send) - Feb 2016
# =============================================================================
KING_OF_ETHER_CONTRACT = '''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * Simplified King of Ether Throne vulnerability
 * Original: Failed .send() was not checked, causing funds to be stuck
 */
contract KingOfEther {
    address public king;
    uint256 public prize;

    constructor() payable {
        king = msg.sender;
        prize = msg.value;
    }

    // VULNERABLE: Unchecked .send() return value
    // If king is a contract that reverts, new king can't claim throne
    function claimThrone() external payable {
        require(msg.value > prize, "Need more ETH to claim throne");

        address previousKing = king;
        uint256 previousPrize = prize;

        king = msg.sender;
        prize = msg.value;

        // BUG: Return value not checked!
        // If previousKing is a contract that reverts on receive,
        // the ETH is stuck and the game breaks
        payable(previousKing).send(previousPrize);
    }

    // VULNERABLE: Same issue with .call()
    function claimThroneV2() external payable {
        require(msg.value > prize, "Need more ETH");

        address previousKing = king;
        uint256 previousPrize = prize;

        king = msg.sender;
        prize = msg.value;

        // BUG: Return value not checked!
        previousKing.call{value: previousPrize}("");
    }
}'''

# =============================================================================
# EXPLOIT 5: Combined Vulnerabilities (Multiple issues)
# =============================================================================
COMBINED_CONTRACT = '''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * Contract with multiple vulnerabilities for comprehensive testing
 * Combines: Reentrancy + Access Control + Unchecked Calls
 */
contract VulnerableVault {
    mapping(address => uint256) public balances;
    address public admin;
    bool public locked;

    constructor() {
        admin = msg.sender;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    // VULNERABILITY 1: Reentrancy
    // External call before state update
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance");

        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");

        balances[msg.sender] = 0;  // State update AFTER external call
    }

    // VULNERABILITY 2: Missing access control
    // Anyone can call this admin function
    function setAdmin(address newAdmin) external {
        admin = newAdmin;
    }

    // VULNERABILITY 3: Missing access control + fund extraction
    function emergencyWithdraw(address to) external {
        payable(to).transfer(address(this).balance);
    }

    // VULNERABILITY 4: Unchecked external call
    function sendRewards(address[] calldata recipients, uint256 amount) external {
        for (uint i = 0; i < recipients.length; i++) {
            // Return value not checked - could silently fail
            recipients[i].call{value: amount}("");
        }
    }

    receive() external payable {}
}'''

EXPLOITS = [
    {
        "name": "The DAO (Reentrancy)",
        "code": DAO_CONTRACT,
        "expected_vulns": ["reentrancy"],
        "expected_severity": "CRITICAL",
        "historical": {
            "date": "June 17, 2016",
            "impact": "$60M stolen (3.6M ETH)",
            "result": "Ethereum hard fork"
        }
    },
    {
        "name": "Parity Wallet (Selfdestruct)",
        "code": PARITY_CONTRACT,
        "expected_vulns": ["unprotected-selfdestruct", "access-control"],
        "expected_severity": "CRITICAL",
        "historical": {
            "date": "November 6, 2017",
            "impact": "$280M frozen permanently",
            "result": "Library contract destroyed"
        }
    },
    {
        "name": "Access Control Bug",
        "code": ACCESS_CONTROL_CONTRACT,
        "expected_vulns": ["access-control"],
        "expected_severity": "CRITICAL",
        "historical": {
            "date": "Various",
            "impact": "Multiple exploits",
            "result": "Token minting, fund theft"
        }
    },
    {
        "name": "King of Ether (Unchecked Send)",
        "code": KING_OF_ETHER_CONTRACT,
        "expected_vulns": ["unchecked-call"],
        "expected_severity": "HIGH",
        "historical": {
            "date": "February 2016",
            "impact": "Game funds stuck",
            "result": "Contract became unusable"
        }
    },
    {
        "name": "Combined Vulnerabilities",
        "code": COMBINED_CONTRACT,
        "expected_vulns": ["reentrancy", "access-control", "unchecked-call"],
        "expected_severity": "CRITICAL",
        "historical": {
            "date": "Test case",
            "impact": "Multiple attack vectors",
            "result": "Complete compromise"
        }
    }
]


def test_exploit(exploit):
    """Test a single exploit and return detailed results."""
    data = json.dumps({"code": exploit["code"]}).encode('utf-8')
    req = urllib.request.Request(
        API_URL,
        data=data,
        headers={'Content-Type': 'application/json'}
    )

    try:
        with urllib.request.urlopen(req, timeout=60) as response:
            result = json.loads(response.read().decode('utf-8'))
            return {
                "success": True,
                "vulnerabilities": result.get("vulnerabilities", []),
                "summary": result.get("summary", {}),
                "exploitCode": result.get("exploitCode"),
                "safetyChecks": result.get("safetyChecks", [])
            }
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }


def check_detection(result, expected_vulns):
    """Check if expected vulnerability types were detected."""
    if not result["success"]:
        return False, []

    found_types = [v["type"] for v in result["vulnerabilities"]]
    detected = []
    missing = []

    for expected in expected_vulns:
        if expected in found_types:
            detected.append(expected)
        else:
            missing.append(expected)

    return len(missing) == 0, detected, missing if missing else None


def format_results(exploit, result, detection_result):
    """Format test results for display."""
    lines = []
    lines.append(f"\n{'='*70}")
    lines.append(f"EXPLOIT: {exploit['name']}")
    lines.append(f"Historical: {exploit['historical']['date']} - {exploit['historical']['impact']}")
    lines.append(f"{'='*70}")

    if not result["success"]:
        lines.append(f"[ERROR] Analysis failed: {result.get('error', 'Unknown error')}")
        return "\n".join(lines), False

    all_detected, detected, missing = detection_result

    # Summary
    summary = result["summary"]
    lines.append(f"\nSummary: Critical={summary.get('critical',0)}, High={summary.get('high',0)}, "
                f"Medium={summary.get('medium',0)}, Low={summary.get('low',0)}")

    # Detection status
    if all_detected:
        lines.append(f"\n[PASS] All expected vulnerabilities detected!")
    else:
        lines.append(f"\n[FAIL] Missing detections: {missing}")

    lines.append(f"Expected: {exploit['expected_vulns']}")
    lines.append(f"Detected: {detected}")

    # Vulnerability details
    lines.append(f"\nVulnerabilities Found ({len(result['vulnerabilities'])}):")
    for vuln in result["vulnerabilities"]:
        severity_icon = {
            "CRITICAL": "ðŸ”´",
            "HIGH": "ðŸŸ ",
            "MEDIUM": "ðŸŸ¡",
            "LOW": "ðŸ”µ"
        }.get(vuln["severity"], "âšª")

        lines.append(f"  {severity_icon} [{vuln['severity']}] {vuln['type']}: {vuln['title']}")
        lines.append(f"     Line {vuln['location']['line']}, Confidence: {vuln['confidence']} ({vuln['confidenceScore']}%)")

        # Check for fix suggestions
        if vuln.get("fixSuggestions"):
            lines.append(f"     Fix Options: {len(vuln['fixSuggestions'])} available")

        # Check for educational content
        if vuln.get("educational"):
            lines.append(f"     Educational: {vuln['educational']['realWorldExample']['name']}")

    # Exploit code
    has_exploit = result.get("exploitCode") is not None
    lines.append(f"\nExploit Code Generated: {'Yes' if has_exploit else 'No'}")
    if has_exploit:
        # Count lines in exploit code
        exploit_lines = len(result["exploitCode"].split("\n"))
        lines.append(f"  Exploit code length: {exploit_lines} lines")

    return "\n".join(lines), all_detected


def main():
    print("=" * 70)
    print("REAL-WORLD EXPLOIT VALIDATION TEST SUITE")
    print(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)

    passed = 0
    failed = 0
    results_log = []

    for exploit in EXPLOITS:
        print(f"\nTesting: {exploit['name']}...", end=" ", flush=True)

        result = test_exploit(exploit)

        if result["success"]:
            detection_result = check_detection(result, exploit["expected_vulns"])
        else:
            detection_result = (False, [], exploit["expected_vulns"])

        formatted, success = format_results(exploit, result, detection_result)
        results_log.append(formatted)

        if success:
            print("PASS")
            passed += 1
        else:
            print("FAIL")
            failed += 1

    # Print detailed results
    for log in results_log:
        print(log)

    # Final summary
    print("\n" + "=" * 70)
    print("FINAL RESULTS")
    print("=" * 70)
    print(f"Passed: {passed}/5")
    print(f"Failed: {failed}/5")
    print(f"Success Rate: {passed/5*100:.0f}%")

    if passed == 5:
        print("\nâœ… ALL EXPLOITS DETECTED CORRECTLY!")
        print("The analyzer is ready for production use.")
    else:
        print(f"\nâŒ {failed} exploit(s) not fully detected.")
        print("Review the results above and fix detection issues.")

    print("=" * 70)

    return passed == 5


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)
