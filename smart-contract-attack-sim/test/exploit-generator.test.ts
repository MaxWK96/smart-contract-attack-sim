import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { generateExploitProofs } from '../src/exploit-generator';
import { Vulnerability } from '../src/types';

describe('Exploit Generator', () => {
  let tempDir: string;

  beforeEach(() => {
    // Create temp directory for each test
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'exploit-test-'));
  });

  afterEach(() => {
    // Clean up temp directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true });
    }
  });

  describe('Reentrancy Exploit Generation', () => {
    it('should generate valid Solidity test file for reentrancy', () => {
      const vuln: Vulnerability = {
        id: 'REENTRANCY-001',
        type: 'reentrancy',
        severity: 'CRITICAL',
        title: 'Reentrancy vulnerability in withdraw()',
        description: 'External call before state update',
        location: {
          line: 20,
          column: 0,
          functionName: 'withdraw',
          contractName: 'TestContract',
        },
        attackVector: 'External call (call) before state update',
        recommendation: 'Use CEI pattern',
        exploitable: true,
      };

      const sourceFile = path.join(__dirname, 'fixtures', 'vulnerable-reentrancy.sol');
      const proofs = generateExploitProofs([vuln], 'VulnerableReentrancy', sourceFile, tempDir);

      expect(proofs.length).toBe(1);
      expect(proofs[0].testFilePath).toContain('exploit_reentrancy_withdraw');
      expect(fs.existsSync(proofs[0].testFilePath)).toBe(true);
    });

    it('should generate valid Solidity syntax', () => {
      const vuln: Vulnerability = {
        id: 'REENTRANCY-001',
        type: 'reentrancy',
        severity: 'CRITICAL',
        title: 'Reentrancy vulnerability in withdraw()',
        description: 'External call before state update',
        location: {
          line: 20,
          column: 0,
          functionName: 'withdraw',
          contractName: 'TestContract',
        },
        attackVector: 'External call (call) before state update',
        recommendation: 'Use CEI pattern',
        exploitable: true,
      };

      const sourceFile = path.join(__dirname, 'fixtures', 'vulnerable-reentrancy.sol');
      const proofs = generateExploitProofs([vuln], 'VulnerableReentrancy', sourceFile, tempDir);

      const testCode = proofs[0].testCode;

      // Check for required Solidity elements
      expect(testCode).toContain('// SPDX-License-Identifier: MIT');
      expect(testCode).toContain('pragma solidity');
      expect(testCode).toContain('import "forge-std/Test.sol"');
      expect(testCode).toContain('contract ReentrancyExploitTest is Test');
      expect(testCode).toContain('function setUp()');
      expect(testCode).toContain('function testReentrancyExploit()');
      expect(testCode).toContain('AttackerContract');
    });

    it('should include attacker contract with fallback', () => {
      const vuln: Vulnerability = {
        id: 'REENTRANCY-001',
        type: 'reentrancy',
        severity: 'CRITICAL',
        title: 'Reentrancy vulnerability in withdraw()',
        description: 'External call before state update',
        location: {
          line: 20,
          column: 0,
          functionName: 'withdraw',
          contractName: 'TestContract',
        },
        attackVector: 'External call (call) before state update',
        recommendation: 'Use CEI pattern',
        exploitable: true,
      };

      const sourceFile = path.join(__dirname, 'fixtures', 'vulnerable-reentrancy.sol');
      const proofs = generateExploitProofs([vuln], 'VulnerableReentrancy', sourceFile, tempDir);

      const testCode = proofs[0].testCode;

      // Check for attacker contract elements
      expect(testCode).toContain('receive() external payable');
      expect(testCode).toContain('fallback() external payable');
      expect(testCode).toContain('attackCount');
    });
  });

  describe('Access Control Exploit Generation', () => {
    it('should generate test for pause() function', () => {
      const vuln: Vulnerability = {
        id: 'ACCESS-001',
        type: 'access-control',
        severity: 'HIGH',
        title: 'Missing access control in pause()',
        description: 'Anyone can pause the contract',
        location: {
          line: 30,
          column: 0,
          functionName: 'pause',
          contractName: 'TestContract',
        },
        attackVector: 'Any address can call pause()',
        recommendation: 'Add onlyOwner modifier',
        exploitable: true,
      };

      const sourceFile = path.join(__dirname, 'fixtures', 'vulnerable-access-control.sol');
      const proofs = generateExploitProofs(
        [vuln],
        'VulnerableAccessControl',
        sourceFile,
        tempDir
      );

      expect(proofs.length).toBe(1);
      expect(proofs[0].testCode).toContain('testAccessControlExploit');
      expect(proofs[0].testCode).toContain('vm.prank(attacker)');
    });
  });

  describe('Non-exploitable Vulnerabilities', () => {
    it('should skip non-exploitable vulnerabilities', () => {
      const vuln: Vulnerability = {
        id: 'INFO-001',
        type: 'unchecked-call',
        severity: 'MEDIUM',
        title: 'Unchecked return value',
        description: 'Return value not checked',
        location: {
          line: 20,
          column: 0,
          functionName: 'someFunc',
          contractName: 'TestContract',
        },
        attackVector: 'None',
        recommendation: 'Check return value',
        exploitable: false, // Not exploitable
      };

      const sourceFile = path.join(__dirname, 'fixtures', 'clean-contract.sol');
      const proofs = generateExploitProofs([vuln], 'TestContract', sourceFile, tempDir);

      expect(proofs.length).toBe(0);
    });
  });

  describe('Exploit Proof Properties', () => {
    it('should include all required proof properties', () => {
      const vuln: Vulnerability = {
        id: 'REENTRANCY-001',
        type: 'reentrancy',
        severity: 'CRITICAL',
        title: 'Reentrancy vulnerability in withdraw()',
        description: 'External call before state update',
        location: {
          line: 20,
          column: 0,
          functionName: 'withdraw',
          contractName: 'TestContract',
        },
        attackVector: 'External call (call) before state update',
        recommendation: 'Use CEI pattern',
        exploitable: true,
      };

      const sourceFile = path.join(__dirname, 'fixtures', 'vulnerable-reentrancy.sol');
      const proofs = generateExploitProofs([vuln], 'VulnerableReentrancy', sourceFile, tempDir);

      expect(proofs[0]).toHaveProperty('vulnerability');
      expect(proofs[0]).toHaveProperty('testFilePath');
      expect(proofs[0]).toHaveProperty('testCode');
      expect(proofs[0]).toHaveProperty('expectedResult');
      expect(proofs[0]).toHaveProperty('estimatedGasCost');
      expect(proofs[0].estimatedGasCost).toBeGreaterThan(0);
    });
  });
});
