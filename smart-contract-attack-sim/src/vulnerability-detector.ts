import {
  Vulnerability,
  VulnerabilityType,
  ParsedContract,
  ContractInfo,
  FunctionInfo,
} from './types';
import {
  findExternalCalls,
  findStateChanges,
  ExternalCallInfo,
  StateChangeInfo,
} from './utils/parser';

let vulnerabilityCounter = 0;

function generateId(type: VulnerabilityType): string {
  vulnerabilityCounter++;
  return `${type.toUpperCase()}-${vulnerabilityCounter.toString().padStart(3, '0')}`;
}

export function detectVulnerabilities(parsed: ParsedContract): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];
  vulnerabilityCounter = 0;

  for (const contract of parsed.contracts) {
    // Skip interfaces and libraries
    if (contract.kind === 'interface' || contract.kind === 'library') {
      continue;
    }

    // Detect reentrancy
    vulnerabilities.push(...detectReentrancy(contract));

    // Detect access control issues
    vulnerabilities.push(...detectAccessControl(contract));

    // Detect unchecked external calls
    vulnerabilities.push(...detectUncheckedCalls(contract));

    // Detect unprotected selfdestruct
    vulnerabilities.push(...detectUnprotectedSelfdestruct(contract));

    // Detect integer overflow/underflow (for Solidity < 0.8.0)
    vulnerabilities.push(...detectIntegerOverflow(contract, parsed.pragmaVersion));
  }

  return vulnerabilities;
}

/**
 * Detect reentrancy vulnerabilities
 * Pattern: External call before state update
 */
function detectReentrancy(contract: ContractInfo): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];

  for (const func of contract.functions) {
    if (!func.body) continue;

    // Skip view/pure functions - they can't modify state
    if (func.stateMutability === 'view' || func.stateMutability === 'pure') {
      continue;
    }

    const externalCalls = findExternalCalls(func.body);
    const stateChanges = findStateChanges(func.body);

    // Check if there's an external call before a state change
    for (const call of externalCalls) {
      // Only check call, send (transfer is safe due to gas limit)
      if (!['call', 'send', 'delegatecall'].includes(call.type)) {
        continue;
      }

      // Find state changes that happen AFTER this external call
      const stateChangesAfterCall = stateChanges.filter(sc => sc.line > call.line);

      if (stateChangesAfterCall.length > 0) {
        const vuln: Vulnerability = {
          id: generateId('reentrancy'),
          type: 'reentrancy',
          severity: 'CRITICAL',
          title: `Reentrancy vulnerability in ${func.name}()`,
          description: `External ${call.type}() at line ${call.line} occurs before state variable update at line ${stateChangesAfterCall[0].line}. An attacker can recursively call ${func.name}() before the state is updated.`,
          location: {
            line: call.line,
            column: 0,
            functionName: func.name,
            contractName: contract.name,
          },
          attackVector: `External call (${call.type}) before state update (${stateChangesAfterCall[0].variableName})`,
          recommendation: 'Apply the Checks-Effects-Interactions pattern: update state variables before making external calls. Consider using ReentrancyGuard from OpenZeppelin.',
          exploitable: true,
        };
        vulnerabilities.push(vuln);
      }
    }
  }

  return vulnerabilities;
}

/**
 * Detect access control vulnerabilities
 * Pattern: Sensitive functions without proper modifiers
 */
function detectAccessControl(contract: ContractInfo): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];

  // Sensitive function patterns that REQUIRE access control
  // Note: 'withdraw' is excluded because it's typically a user-facing function
  const sensitivePatterns = [
    'mint', 'burn', 'pause', 'unpause',
    'setOwner', 'changeOwner', 'updateOwner', 'setAdmin', 'upgrade',
    'destroy', 'selfdestruct', 'kill', 'setPrice', 'setFee',
    'transferOwnership', 'renounceOwnership',
  ];

  // Patterns that are sensitive only when they allow arbitrary transfers
  // (not user withdrawing their own funds)
  const transferPatterns = ['transferFunds', 'emergencyWithdraw', 'sweep'];

  // Access control modifiers
  const accessControlModifiers = [
    'onlyOwner', 'onlyAdmin', 'onlyRole', 'onlyAuthorized',
    'restricted', 'auth', 'authorized', 'requiresAuth',
  ];

  for (const func of contract.functions) {
    // Skip private/internal functions
    if (func.visibility === 'private' || func.visibility === 'internal') {
      continue;
    }

    // Skip constructor, fallback, receive
    if (func.name === 'constructor' || func.name === 'fallback' || func.name === 'receive') {
      continue;
    }

    // Check if function name matches sensitive patterns
    const isSensitive = sensitivePatterns.some(pattern =>
      func.name.toLowerCase().includes(pattern.toLowerCase())
    );

    const isTransferPattern = transferPatterns.some(pattern =>
      func.name.toLowerCase().includes(pattern.toLowerCase())
    );

    if (!isSensitive && !isTransferPattern) continue;

    // Check if function has access control modifier
    const hasAccessControl = func.modifiers.some(mod =>
      accessControlModifiers.some(acMod =>
        mod.toLowerCase().includes(acMod.toLowerCase())
      )
    );

    // Check for require(msg.sender) pattern in function body
    const hasRequireSender = checkForMsgSenderRequire(func.body);

    // Check if function checks user's own balance (for transfer patterns)
    const checksUserBalance = isTransferPattern && checkForUserBalanceCheck(func.body);

    if (!hasAccessControl && !hasRequireSender && !checksUserBalance) {
      vulnerabilities.push({
        id: generateId('access-control'),
        type: 'access-control',
        severity: 'HIGH',
        title: `Missing access control in ${func.name}()`,
        description: `The function ${func.name}() appears to be a sensitive function but lacks access control modifiers.`,
        location: {
          line: func.line,
          column: 0,
          functionName: func.name,
          contractName: contract.name,
        },
        attackVector: `Any address can call ${func.name}() without authorization`,
        recommendation: 'Add an appropriate access control modifier (e.g., onlyOwner) to restrict who can call this function.',
        exploitable: true,
      });
    }
  }

  return vulnerabilities;
}

function checkForUserBalanceCheck(body: any): boolean {
  // Check if function accesses balances[msg.sender] indicating
  // the user can only affect their own funds
  if (!body) return false;

  let found = false;

  function traverse(node: any) {
    if (!node || found) return;

    // Look for balances[msg.sender] pattern
    if (node.type === 'IndexAccess') {
      const base = node.base;
      const index = node.index;

      if (base?.type === 'Identifier' && base.name?.toLowerCase().includes('balance')) {
        if (containsMsgSender(index)) {
          found = true;
          return;
        }
      }
    }

    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          for (const child of node[key]) {
            traverse(child);
          }
        } else {
          traverse(node[key]);
        }
      }
    }
  }

  traverse(body);
  return found;
}

function checkForMsgSenderRequire(body: any): boolean {
  if (!body) return false;

  let found = false;

  function traverse(node: any) {
    if (!node || found) return;

    // Look for require() or if() statements that check msg.sender
    if (node.type === 'FunctionCall') {
      const expr = node.expression;
      if (expr?.type === 'Identifier' && expr.name === 'require') {
        const args = node.arguments || [];
        for (const arg of args) {
          if (containsMsgSender(arg)) {
            found = true;
            return;
          }
        }
      }
    }

    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          for (const child of node[key]) {
            traverse(child);
          }
        } else {
          traverse(node[key]);
        }
      }
    }
  }

  traverse(body);
  return found;
}

function containsMsgSender(node: any): boolean {
  if (!node) return false;

  if (node.type === 'MemberAccess' &&
      node.expression?.type === 'Identifier' &&
      node.expression?.name === 'msg' &&
      node.memberName === 'sender') {
    return true;
  }

  for (const key in node) {
    if (node[key] && typeof node[key] === 'object') {
      if (Array.isArray(node[key])) {
        for (const child of node[key]) {
          if (containsMsgSender(child)) return true;
        }
      } else {
        if (containsMsgSender(node[key])) return true;
      }
    }
  }

  return false;
}

/**
 * Detect unchecked external call return values
 */
function detectUncheckedCalls(contract: ContractInfo): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];

  for (const func of contract.functions) {
    if (!func.body) continue;

    // Check if the function body has call/send and whether return values are checked
    const uncheckedCalls = findUncheckedExternalCalls(func.body);

    for (const call of uncheckedCalls) {
      vulnerabilities.push({
        id: generateId('unchecked-call'),
        type: 'unchecked-call',
        severity: 'MEDIUM',
        title: `Unchecked ${call.type}() return value in ${func.name}()`,
        description: `The return value of ${call.type}() at line ${call.line} is not checked. This can lead to silent failures.`,
        location: {
          line: call.line,
          column: 0,
          functionName: func.name,
          contractName: contract.name,
        },
        attackVector: `Failed ${call.type}() will not revert, potentially leaving contract in inconsistent state`,
        recommendation: `Check the return value of ${call.type}() and handle failures appropriately.`,
        exploitable: false,
      });
    }
  }

  return vulnerabilities;
}

interface UncheckedCall {
  type: string;
  line: number;
}

function findUncheckedExternalCalls(body: any): UncheckedCall[] {
  const uncheckedCalls: UncheckedCall[] = [];

  function traverse(node: any, parentLine?: number) {
    if (!node) return;

    const currentLine = node.loc?.start?.line || parentLine;

    // Check for ExpressionStatement containing a direct call
    // This means the call is not assigned to a variable
    if (node.type === 'ExpressionStatement') {
      const expr = node.expression;
      if (expr?.type === 'FunctionCall') {
        let callExpr = expr.expression;

        // Handle NameValueExpression
        if (callExpr?.type === 'NameValueExpression') {
          callExpr = callExpr.expression;
        }

        if (callExpr?.type === 'MemberAccess') {
          const memberName = callExpr.memberName;
          if (['call', 'send'].includes(memberName)) {
            uncheckedCalls.push({
              type: memberName,
              line: currentLine || 0,
            });
          }
        }
      }
    }

    // Recursively traverse
    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          for (const child of node[key]) {
            traverse(child, currentLine);
          }
        } else {
          traverse(node[key], currentLine);
        }
      }
    }
  }

  traverse(body);
  return uncheckedCalls;
}

/**
 * Detect unprotected selfdestruct
 */
function detectUnprotectedSelfdestruct(contract: ContractInfo): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];

  for (const func of contract.functions) {
    if (!func.body) continue;

    const selfdestructCalls = findSelfdestructCalls(func.body);

    for (const call of selfdestructCalls) {
      // Check if function has access control
      const hasAccessControl = func.modifiers.length > 0 ||
                                checkForMsgSenderRequire(func.body);

      if (!hasAccessControl && (func.visibility === 'public' || func.visibility === 'external')) {
        vulnerabilities.push({
          id: generateId('unprotected-selfdestruct'),
          type: 'unprotected-selfdestruct',
          severity: 'CRITICAL',
          title: `Unprotected selfdestruct in ${func.name}()`,
          description: `The selfdestruct call at line ${call.line} is in a function without access control. Anyone can destroy this contract.`,
          location: {
            line: call.line,
            column: 0,
            functionName: func.name,
            contractName: contract.name,
          },
          attackVector: 'Any address can call this function and destroy the contract, stealing all ETH',
          recommendation: 'Add access control modifiers to restrict who can call functions containing selfdestruct.',
          exploitable: true,
        });
      }
    }
  }

  return vulnerabilities;
}

function findSelfdestructCalls(body: any): { line: number }[] {
  const calls: { line: number }[] = [];

  function traverse(node: any, parentLine?: number) {
    if (!node) return;

    const currentLine = node.loc?.start?.line || parentLine;

    if (node.type === 'FunctionCall') {
      const expr = node.expression;
      if (expr?.type === 'Identifier' && (expr.name === 'selfdestruct' || expr.name === 'suicide')) {
        calls.push({ line: currentLine || 0 });
      }
    }

    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          for (const child of node[key]) {
            traverse(child, currentLine);
          }
        } else {
          traverse(node[key], currentLine);
        }
      }
    }
  }

  traverse(body);
  return calls;
}

/**
 * Detect integer overflow/underflow (for Solidity < 0.8.0)
 */
function detectIntegerOverflow(contract: ContractInfo, pragmaVersion: string | null): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];

  // Check if Solidity version is < 0.8.0 (which has built-in overflow checks)
  if (pragmaVersion) {
    const version = extractVersion(pragmaVersion);
    if (version && version.major >= 0 && version.minor >= 8) {
      // Solidity 0.8+ has built-in overflow checks, skip unless using unchecked
      return detectUncheckedBlocks(contract);
    }
  }

  for (const func of contract.functions) {
    if (!func.body) continue;

    const arithmeticOps = findArithmeticOperations(func.body);

    for (const op of arithmeticOps) {
      vulnerabilities.push({
        id: generateId(op.type === '+' || op.type === '*' ? 'integer-overflow' : 'integer-underflow'),
        type: op.type === '+' || op.type === '*' ? 'integer-overflow' : 'integer-underflow',
        severity: 'HIGH',
        title: `Potential integer ${op.type === '+' || op.type === '*' ? 'overflow' : 'underflow'} in ${func.name}()`,
        description: `Arithmetic operation (${op.type}) at line ${op.line} may ${op.type === '+' || op.type === '*' ? 'overflow' : 'underflow'} in Solidity < 0.8.0.`,
        location: {
          line: op.line,
          column: 0,
          functionName: func.name,
          contractName: contract.name,
        },
        attackVector: `Supply values that cause the operation to ${op.type === '+' || op.type === '*' ? 'overflow' : 'underflow'}, bypassing validation`,
        recommendation: 'Use SafeMath library or upgrade to Solidity 0.8.0+ which has built-in overflow checks.',
        exploitable: true,
      });
    }
  }

  return vulnerabilities;
}

function detectUncheckedBlocks(contract: ContractInfo): Vulnerability[] {
  const vulnerabilities: Vulnerability[] = [];

  for (const func of contract.functions) {
    if (!func.body) continue;

    const uncheckedOps = findUncheckedArithmetic(func.body);

    for (const op of uncheckedOps) {
      vulnerabilities.push({
        id: generateId(op.type === '+' || op.type === '*' ? 'integer-overflow' : 'integer-underflow'),
        type: op.type === '+' || op.type === '*' ? 'integer-overflow' : 'integer-underflow',
        severity: 'MEDIUM',
        title: `Unchecked arithmetic in ${func.name}()`,
        description: `Arithmetic operation inside unchecked block at line ${op.line} bypasses overflow/underflow checks.`,
        location: {
          line: op.line,
          column: 0,
          functionName: func.name,
          contractName: contract.name,
        },
        attackVector: 'Values may overflow/underflow without reverting',
        recommendation: 'Ensure unchecked blocks are only used when overflow/underflow is mathematically impossible.',
        exploitable: true,
      });
    }
  }

  return vulnerabilities;
}

interface ArithmeticOp {
  type: string;
  line: number;
}

function findArithmeticOperations(body: any): ArithmeticOp[] {
  const ops: ArithmeticOp[] = [];

  function traverse(node: any, parentLine?: number) {
    if (!node) return;

    const currentLine = node.loc?.start?.line || parentLine;

    if (node.type === 'BinaryOperation') {
      if (['+', '-', '*', '**'].includes(node.operator)) {
        ops.push({ type: node.operator, line: currentLine || 0 });
      }
    }

    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          for (const child of node[key]) {
            traverse(child, currentLine);
          }
        } else {
          traverse(node[key], currentLine);
        }
      }
    }
  }

  traverse(body);
  return ops;
}

function findUncheckedArithmetic(body: any): ArithmeticOp[] {
  const ops: ArithmeticOp[] = [];

  function traverse(node: any, inUnchecked: boolean, parentLine?: number) {
    if (!node) return;

    const currentLine = node.loc?.start?.line || parentLine;

    // Check if we're entering an unchecked block
    if (node.type === 'UncheckedStatement') {
      // Traverse inside unchecked block
      traverse(node.block, true, currentLine);
      return;
    }

    if (inUnchecked && node.type === 'BinaryOperation') {
      if (['+', '-', '*', '**'].includes(node.operator)) {
        ops.push({ type: node.operator, line: currentLine || 0 });
      }
    }

    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          for (const child of node[key]) {
            traverse(child, inUnchecked, currentLine);
          }
        } else {
          traverse(node[key], inUnchecked, currentLine);
        }
      }
    }
  }

  traverse(body, false);
  return ops;
}

function extractVersion(pragma: string): { major: number; minor: number; patch: number } | null {
  // Match patterns like "^0.8.0", ">=0.7.0 <0.9.0", "0.8.17"
  const match = pragma.match(/(\d+)\.(\d+)\.?(\d*)/);
  if (match) {
    return {
      major: parseInt(match[1], 10),
      minor: parseInt(match[2], 10),
      patch: match[3] ? parseInt(match[3], 10) : 0,
    };
  }
  return null;
}
